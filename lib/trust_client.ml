open Lwt

(* The client policy includes a couple of fields beyond the conf in order
   to be able to update it. new_conf indicates where the trust server is
   located, which will provide a policy update *)
type client_policy = { conf : Abuilder.Conf.t ; 
		       version : int option ; 
		       use_until : float ; 
		       new_conf : ( ( string * int ) * Abuilder.Conf.t ) option
		     }

type t = < connect : string * int -> (Tls_lwt.ic * Tls_lwt.oc) Lwt.t ;
	   force_update : unit ;
	   get_policy : client_policy ;
	   set_policy : client_policy -> unit
	 >

let _OUTLEVEL = 10
let db l id msg = 
  if l <= _OUTLEVEL then
    lwt () = Lwt_io.printf "Trust_client %s (%i): %s\n" id l msg in
lwt () = Lwt_io.flush_all () in
    return ()
  else
    return ()

(* Allows for convenient replacement of a policy's field *)
let replace_field ?conf ?ver ?use_time ?new_c client_p =
  let c = match conf with
    | None -> client_p.conf
    | Some c -> c
  in
  let v = match ver with
    | None -> client_p.version
    | Some v -> v
  in 
  let ut = match use_time with
    | None -> client_p.use_until
    | Some t -> t
  in
  let nc = match new_c with
    | None -> client_p.new_conf
    | Some c -> c
  in
  { conf = c ; version = v ; use_until = ut ; new_conf = nc }

(* Assemble the policy with all its fields using this function.
   A policy must at minimum contain a configuration. *)
let client_policy ?ver ?use_time ?new_c conf =
  let time = match use_time with
    | Some t -> t
    | None -> -1.0
  in
  { conf = conf ; version = ver ; use_until = time ; new_conf = new_c }

(* Takes a policy and returns an update if the given policy is stale.
   Alternatively an update can be forced using the '?force' parameter,
   in which case the policy will also be updated if it is still valid.
   'attempts' allows the maximum number of attempts to be specified,
   that are made to update the policy. *)
let rec update_policy ?force policy attempts =
  let f = match force with
    | None -> false
    | Some b -> b
  in
  let now = Unix.gettimeofday () in

  (* Check if we need to update the policy at all *)
  if not f && (policy.use_until > now || policy.use_until < 0.0) then
    return policy
  else
    let ((host, port), conf) = match policy.new_conf with
      | None -> raise (Failure "No data to retrieve new policy available")
      | Some nc -> nc
    in
   
    lwt auth = Abuilder.Conf.build conf (host, port) in
    lwt (ic, oc) = Tls_lwt.connect auth (host, port) in
    lwt resp = Lwt_io.(write_value oc `Policy >> read_value ic) in
    lwt () = Lwt_io.(close oc >> close ic) in

    match resp with
    | `Policy p ->
       let now = Unix.gettimeofday () in
       if p.use_until < now && p.use_until >= 0.0 then
	 if attempts > 0 then
	   update_policy p (attempts - 1)
	 else
	   raise (Failure "Max attempts exceeded")
       else
	 (* The update was successfully received. Now prepare the
	    configuration, s.t. any caches are ready for use. *)
	 lwt prep_caches = Abuilder.Conf.prepare p.conf in
         let poly = replace_field ~conf:prep_caches p in
	 return poly
    | _ -> raise (Abuilder.Authenticator.Unexpected_response "Expected `Policy")

(* Instantiates a new client when provided with a policy *)
let new_client_object policy =
  object
    val mutable policy = policy
    method connect (host, port) = begin
      (* Assign each connection a random ID, such that we can identify which
	 output was generated by which connection when debugging *)
      let id = Random.self_init (); string_of_int (Random.int 1000) ^ "-" ^ string_of_int (Random.int 1000) in
      lwt () = db 10 id ("connecting to " ^ host ^ ":" ^ string_of_int port) in
      
      let now = Unix.gettimeofday () in

      (* Make sure that the policy is up to date *)
      lwt poly = update_policy policy 10 in
      
      lwt () = db 10 id "Policy is now up to date." in
      
      policy <- poly;
      
      (* Now build and use the given policy to connect to the given host/port *)
      lwt auth = Abuilder.Conf.build policy.conf (host, port) in
      lwt () = db 10 id "Built policy, trying to connect..." in
      Tls_lwt.connect auth (host, port)
    end

    (* The following should not be necessary any more as updates are
       performed automatically. If it is still required, it should be
       trivial to implement with somthing like:
          "update_policy ~force:true !policy 10"
    *)
    method force_update = Printf.printf "Not yet implemented"

    method get_policy = policy
    method set_policy p = policy <- p
  end

(* Instantiates a new client given a policy and also makes sure said
   policy is self-contained and prepared *)
let of_policy policy = 
  lwt contained_conf = Abuilder.Conf.contain policy.conf in
  lwt cont_prep_conf = Abuilder.Conf.prepare contained_conf in
  return (new_client_object (replace_field ~conf:cont_prep_conf policy))

(* Use this function if only the trust server information is provided.
   This function will automatically fetch a policy from the TS and
   instantiate a client with it *)
let of_ts_info ((host, port), conf) =
  lwt auth = Abuilder.Conf.build conf (host, port) in
  lwt (ic, oc) = Tls_lwt.connect auth (host, port) in
  lwt resp = Lwt_io.(write_value oc `Policy >> read_value ic) in
  lwt () = Lwt_io.(close oc >> close ic) in

  let policy = match resp with
    | `Policy p -> p
    | _ -> raise (Failure "Couldn't retrieve policy")
  in

  (* Instantiate the actual client *)
  of_policy policy
